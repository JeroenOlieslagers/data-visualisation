(window["webpackJsonpproject-portfolio"]=window["webpackJsonpproject-portfolio"]||[]).push([[0],{171:function(e,t,a){e.exports=a.p+"static/media/fano_window_refr.c556c42b.svg"},172:function(e,t,a){e.exports=a.p+"static/media/book_cover.cdf0f8da.jpg"},178:function(e,t,a){e.exports=a.p+"static/media/logo.ee7cd8ed.svg"},184:function(e,t,a){e.exports=a.p+"static/media/abc.cc2c3055.svg"},185:function(e,t,a){e.exports=a.p+"static/media/fano_window.05cbecb4.svg"},186:function(e,t,a){e.exports=a.p+"static/media/isi_hist.2d099cc1.svg"},187:function(e,t,a){e.exports=a.p+"static/media/fano.e25c800e.svg"},188:function(e,t,a){e.exports=a.p+"static/media/cv.3058790b.svg"},189:function(e,t,a){e.exports=a.p+"static/media/spike_train_bw.045475bf.svg"},190:function(e,t,a){e.exports=a.p+"static/media/spike_train_refr.5bbf66f8.svg"},191:function(e,t,a){e.exports=a.p+"static/media/isi_refr.1b2fafb3.svg"},192:function(e,t,a){e.exports=a.p+"static/media/cv_refr.af9b39bc.svg"},193:function(e,t,a){e.exports=a.p+"static/media/isis_refr.497828fc.svg"},194:function(e,t,a){e.exports=a.p+"static/media/norm_approx.385a157a.svg"},195:function(e,t,a){e.exports=a.p+"static/media/perf1.9c184698.svg"},196:function(e,t,a){e.exports=a.p+"static/media/perf2.c4b61154.svg"},197:function(e,t,a){e.exports=a.p+"static/media/method_of_moments.8c9931f6.svg"},198:function(e,t,a){e.exports=a.p+"static/media/mean_fit.0ab27344.svg"},199:function(e,t,a){e.exports=a.p+"static/media/var_fit.3b7916c5.svg"},210:function(e,t,a){e.exports=a(409)},215:function(e,t,a){},216:function(e,t,a){},409:function(e,t,a){"use strict";a.r(t);var n=a(56),r=a(1),i=a.n(r),s=a(42),l=a.n(s),o=(a(215),a(40)),c=a(32),m=a(43),u=a(44),h=a(45),p=a(178),d=a.n(p),f=(a(216),a(439)),g=a(469),b=a(442),y=a(468),v=a(472),_=a(444),E=a(445),x=function(e,t,a,n){return{type:"SLIDER_CHANGE",newValue:t,value:a,event:e,name:n}},w=function(e,t,a){return{type:"INPUT_CHANGE",event:e,value:t,name:a}},k=function(e,t,a){return{type:"CLIP",max:e,value:t,name:a}},M=function(e){return{type:"TOGGLE_UPDATE_DATA",name:e}},T=function(e){return{type:"TOGGLE_PERFORMANCE_CHART",name:e}},j=a(74),N=a(443),I=function(e){function t(){var e;return Object(o.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).handleOpen=function(t){t.stopPropagation(),e.setState({anchorEl:t.currentTarget,tabId:t.currentTarget.id,open:!e.state.open})},e.changeStatsTab=function(t,a){e.props.setTab(t,a),e.handleClose(t),e.setState({statsTab:a})},e.changeNeurTab=function(t,a){e.props.setTab(t,a),e.handleClose(t),e.setState({neurTab:a})},e.handleClose=function(){e.setState({anchorEl:null,tabId:null,open:!e.state.open})},e.state={statsTab:"normal",neurTab:"neurInfo",open:!1},e}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){var e=this;return i.a.createElement(O,null,i.a.createElement(f.a,null,i.a.createElement(g.a,{centered:!0,value:this.props.selectedTab,onChange:this.props.setTab},i.a.createElement(b.a,{label:"home",value:"home"}),i.a.createElement(b.a,{classes:{wrapper:"stats__tab"},label:"Stats",value:this.state.statsTab,id:"stats-tab",icon:i.a.createElement(N.a,null),onClick:this.handleOpen}),i.a.createElement(b.a,{classes:{wrapper:"stats__tab"},label:"Theoretical Neuroscience",value:this.state.neurTab,id:"neur-tab",icon:i.a.createElement(N.a,null),onClick:this.handleOpen}),i.a.createElement(b.a,{label:"Ray Tracing",value:"rayTracing"}),i.a.createElement(b.a,{label:"IPython Notebooks",value:"ipython"})),i.a.createElement(y.a,{open:this.state.open,anchorEl:this.state.anchorEl,onClose:this.handleClose,anchorOrigin:{vertical:"bottom",horizontal:"left"},transformOrigin:{vertical:"top",horizontal:"left"}},i.a.createElement(v.a,{className:"stats__menu",style:{display:"stats-tab"===this.state.tabId?"flex":"none"},onClick:function(t){return e.changeStatsTab(t,"normal")}},"Normal"),i.a.createElement(v.a,{className:"stats__menu",style:{display:"stats-tab"===this.state.tabId?"flex":"none"},onClick:function(t){return e.changeStatsTab(t,"poisson")}},"Poisson"),i.a.createElement(v.a,{className:"stats__menu",style:{display:"neur-tab"===this.state.tabId?"flex":"none"},onClick:function(t){return e.changeNeurTab(t,"neurInfo")}},"Info"),i.a.createElement(v.a,{className:"stats__menu",style:{display:"neur-tab"===this.state.tabId?"flex":"none"},onClick:function(t){return e.changeNeurTab(t,"chapter1")}},"Chapter 1"),i.a.createElement(v.a,{className:"stats__menu",style:{display:"neur-tab"===this.state.tabId?"flex":"none"},onClick:function(t){return e.changeNeurTab(t,"neurExt")}},"Extensions"))))}}]),t}(i.a.Component);function O(e){var t=e.children,a=e.window,n=Object(_.a)({target:a?a():void 0});return i.a.createElement(E.a,{appear:!1,direction:"down",in:!n},t)}var C={setTab:function(e,t){return{type:"SET_TAB",value:t}}},D=Object(j.b)((function(e){return{selectedTab:e.selectedTab}}),C)(I),P=a(446),R=a(457),S=a(458),B=a(459),F=a(470),L=a(460),q=a(128),A=a(473),H=a(471);function U(e,t){return t<0?0:Math.pow(e,t)*Math.exp(-e)/function e(t){return 0===t?1:t*e(t-1)}(t)}function G(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=0,n=0;0===a;)a=Math.random();for(;0===n;)n=Math.random();return Math.sqrt(-2*Math.log(a))*Math.cos(2*Math.PI*n)*t+e}function W(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(e>1e3)throw new Error("Value of Lambda too large");for(var t=0,a=Math.exp(-e),n=a,r=Math.random();n<r;)n+=a*=e/++t;return t}function z(e){console.time("histogram");var t=[],a=[],n=[],r=Object.keys(e[0]).slice(1,e.length);return e.forEach((function(e){r.forEach((function(i){(n=-1===Math.sign(e[i])?a:t)[e[i]]?n[e[i]][i]+=1:(n[e[i]]={},r.forEach((function(t){n[e[i]][t]=0})),n[e[i]][i]=1)}))})),console.timeEnd("histogram"),[t,a]}function X(e){var t=Math.floor(Math.log10(0===e?1:e));return(0===t?e:Math.round(e/Math.pow(10,t)))+9*t}var V=function(){function e(t,a){Object(o.a)(this,e),this.x=t,this.y=a}return Object(c.a)(e,[{key:"vMinus",value:function(t){return new e(this.x-t.x,this.y-t.y)}},{key:"vPlus",value:function(t){return new e(this.x+t.x,this.y+t.y)}},{key:"mult",value:function(t){return new e(this.x*t,this.y*t)}},{key:"dot",value:function(e){return this.x*e.x+this.y*e.y}},{key:"set",value:function(e,t){this.x=e,this.y=t}},{key:"normalise",value:function(){var e=Math.sqrt(this.l22);this.x=this.x/e,this.y=this.y/e}},{key:"p",get:function(){return[this.x,this.y]}},{key:"l22",get:function(){return Math.pow(this.x,2)+Math.pow(this.y,2)}}]),e}(),$=function(e){function t(){return Object(o.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){var e=this;return i.a.createElement("div",{className:"slider__container"},i.a.createElement(q.a,{id:"input-slider",gutterBottom:!0},this.props.label),i.a.createElement(P.a,{container:!0,spacing:2,alignItems:"center"},i.a.createElement(P.a,{item:!0},this.props.icon),i.a.createElement(P.a,{item:!0,xs:!0},i.a.createElement(A.a,{value:X(this.props.value),onChange:function(t,a){return e.props.sliderChange(t,a,e.props.valueName,e.props.name)},onChangeCommitted:function(){return e.props.toggleUpdateData(e.props.name)},"aria-labelledby":"input-slider",max:X(this.props.max),className:"slider"})),i.a.createElement(P.a,{item:!0},i.a.createElement(H.a,{className:"slider__input",value:this.props.value,margin:"dense",onChange:function(t){return e.props.inputChange(t,e.props.valueName,e.props.name)},onBlur:function(){return e.props.handleBlur(e.props.valueName,e.props.max,e.props.name)},inputProps:{"aria-labelledby":"input-slider"}}))))}}]),t}(i.a.Component),Y=a(453),Z=a(454),Q=a(455),J=a(456),K=a(78),ee=a(447),te=a(448),ae=a(449),ne=a(451),re=a(452),ie=a(183),se=a.n(ie),le=a(450);function oe(e){var t=i.a.useState(e.expanded),a=Object(K.a)(t,2),n=a[0],r=a[1];return i.a.createElement(ee.a,{className:e.className},i.a.createElement(te.a,{className:"card__header",disableTypography:!0,title:i.a.createElement("div",{className:"card__header__content"},i.a.createElement(q.a,{variant:"h5",className:"card__header__title"},e.title),i.a.createElement(ae.a,{onClick:function(){r(!n)},"aria-expanded":n,"aria-label":"show more",className:se()("card__header__expand",n?"card__header__expand--open":"")},i.a.createElement(le.a,null))),avatar:e.avatar}),i.a.createElement(ne.a,{in:n},i.a.createElement(re.a,null,e.children)))}var ce=function(e){function t(){var e,a;Object(o.a)(this,t);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return(a=Object(m.a)(this,(e=Object(u.a)(t)).call.apply(e,[this].concat(r)))).handleBlur=function(e,t,n){a.props.clip(t,e,n),a.props.toggleUpdateData(n)},a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){var e=this;return i.a.createElement(oe,{title:"Graph Configuration",avatar:i.a.createElement(Y.a,null),expanded:!0},i.a.createElement(P.a,{container:!0},i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement($,{label:"Mean",name:"normal",valueName:"mean",value:this.props.mean.normal,inputChange:this.props.inputChange,sliderChange:this.props.sliderChange,toggleUpdateData:this.props.toggleUpdateData,handleBlur:this.handleBlur,max:1e5,icon:i.a.createElement(Z.a,null)})),i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement($,{label:"Standard Deviation",name:"normal",valueName:"stDev",value:this.props.stDev.normal,inputChange:this.props.inputChange,sliderChange:this.props.sliderChange,toggleUpdateData:this.props.toggleUpdateData,handleBlur:this.handleBlur,max:1e3,icon:i.a.createElement(Q.a,null)})),i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement($,{label:"Samples",name:"normal",valueName:"samples",value:this.props.samples.normal,inputChange:this.props.inputChange,sliderChange:this.props.sliderChange,toggleUpdateData:this.props.toggleUpdateData,handleBlur:this.handleBlur,max:1e6,icon:i.a.createElement(J.a,null)})),i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement(R.a,{component:"fieldset",className:"stats__performance-chart"},i.a.createElement(S.a,null,i.a.createElement(B.a,{control:i.a.createElement(F.a,{checked:this.props.performanceChart.normal,onChange:function(){return e.props.togglePerformanceChart("normal")}}),label:"Performance Chart"})),i.a.createElement(L.a,{margin:"dense"},"Tick for faster rendering (recommended at high variances)")))))}}]),t}(i.a.Component);var me={sliderChange:x,inputChange:w,clip:k,toggleUpdateData:M,togglePerformanceChart:T},ue=Object(j.b)((function(e){return{mean:e.mean,stDev:e.stDev,samples:e.samples,performanceChart:e.performanceChart}}),me)(ce),he=a(201),pe=a(463),de=a(16),fe=(a(138),a(39)),ge=a(47),be=a(166),ye=a(127);var ve=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.samples,a=void 0===t?100:t,n=e.countries,r=void 0===n?void 0:n,i=e.rules,s=void 0===i?[]:i,l=e.slope,o=void 0===l?.1:l,c=e.isStatic,m=void 0===c||c,u=e.independent,h=void 0===u?"id":u,p=e.dependent,d=void 0===p?[{name:"column-1",mean:200,stDev:20,rules:[""]},{name:"column-2",mean:50,stDev:5,rules:[""]}]:p,f=[],g={};if("date"===h){var b=new Date;b.setDate(b.getDate()-a),g.date=b}else if("id"===h)g.id=1;else if("country"===h){if(!r)throw new Error("Countries parameter needs to be defined");g.id=r[0]}d.forEach((function(e,t){g[e.name]=Math.round(G(e.mean,e.stDev))}));for(var y=g,v={},_=0;_<(r?r.length:a);_++){switch(v={},h){case"date":var E=new Date;E.setDate(g.date.getDate()+_),v.date=E;break;case"id":v.id=g.id+_;break;case"country":v.id=r[_];break;default:throw new Error("Independent variable not valid")}d.forEach((function(e,t){e.rules.includes("uniform")?v[e.name]=Math.round(Math.random()*(6*e.stDev)+(e.mean-3*e.stDev)):e.rules.includes("poisson")?v[e.name]=Math.round(W(e.mean)):v[e.name]=Math.round(G(e.mean,e.stDev)),(s.includes("positive")||e.rules.includes("positive"))&&v[e.name]<0&&(v[e.name]=0),m||(v[e.name]=y[e.name]+Math.round((Math.random()<.5+o?1:-1)*v[e.name]),y=v)})),f.push(v)}return f},_e=a(461),Ee=function(e){function t(){var e;return Object(o.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).chart=null,fe.d.commercialLicense=!0,e.prevPerf=!1,e}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){this.createChart()}},{key:"createData",value:function(){var e=this.props.samples.normal,t=this.props.mean.normal,a=this.props.stDev.normal,n=z(ve({samples:e,dependent:[{name:"column-1",mean:t,stDev:a,rules:[]},{name:"column-3",mean:t,stDev:a,rules:["uniform"]}]})),r=n[0],i=Object.keys(r),s=n[1],l=Object.keys(s).sort((function(e,t){return Number(e)-Number(t)})),o=l.concat(i),c=[],m=[];o.forEach((function(n,i){m=-1===Math.sign(Number(n))?s:r;var l,o,u,h={};h.id=Number(n),h["column-1"]=m[n]["column-1"],h["column-2"]=Math.round((l=t,o=a,u=parseInt(n,10),1/(o*Math.sqrt(2*Math.PI))*Math.exp(-.5*Math.pow((u-l)/o,2))*e)),h["column-3"]=m[n]["column-3"],c[0]?h["column-4"]=c[i-1]["column-4"]+m[n]["column-1"]:h["column-4"]=h["column-1"],c.push(h)}));var u=!1;return 0!==l.length&&(u=!0),[c,u]}},{key:"createChart",value:function(){fe.g(be.a),this.props.performanceChart.normal?fe.f(ye.a):fe.g(ye.a),this.chart=fe.c(this.refs.normal_chart,ge.g);var e=this.chart;e.categoryField="category";var t=this.createData();e.data=t[0];var a=t[1],n=e.xAxes.push(new ge.a);n.dataFields.category="id",n.renderer.grid.strokeDasharray=3,this.range=n.axisRanges.create(),this.range.category=a?0:void 0,this.range.label.paddingTop=2,this.range.label.fontSize=12,this.range.grid.stroke=fe.b("grey"),this.range.grid.strokeWidth=1,this.range.grid.strokeOpacity=.7,e.yAxes.push(new ge.f).renderer.grid.strokeDasharray=3;var r=new fe.a,i=e.yAxes.push(new ge.f);i.renderer.grid.template.disabled=!0,i.renderer.line.strokeOpacity=1,i.renderer.line.stroke=r.getIndex(3),i.renderer.line.strokeWidth=2,i.renderer.opposite=!0;var s=e.series.push(this.props.performanceChart.normal?new ge.e:new ge.b);s.name="Normal (artificial, Box-Muller)",s.dataFields.valueY="column-1",s.dataFields.categoryX="id",s.strokeWidth=1,s.fillOpacity=1,s.tensionX=1,this.props.performanceChart.normal||(s.columns.template.width=fe.e(80),s.fillOpacity=0);var l=e.series.push(new ge.d);l.name="Normal (analytical)",l.dataFields.valueY="column-2",l.dataFields.categoryX="id",l.strokeWidth=1,l.tensionX=1;var o=e.series.push(new ge.d);o.name="Uniform",o.dataFields.valueY="column-3",o.dataFields.categoryX="id",o.strokeWidth=1,o.tensionX=1,o.hidden=!0;var c=e.series.push(new ge.d);c.name="CDF (Box-Muller)",c.dataFields.valueY="column-4",c.dataFields.categoryX="id",c.strokeWidth=1,c.tensionX=1,c.yAxis=i,e.cursor=new ge.h,e.legend=new ge.c;var m=e.legend.markers.template;m.width=12,m.height=12;var u=e.legend.itemContainers.template;u.paddingRight=5,u.paddingLeft=5,u.paddingTop=0,u.paddingBottom=0,e.paddingBottom=20,e.paddingTop=40}},{key:"render",value:function(){if(this.props.updateData.normal){if(this.props.performanceChart.normal&&this.prevPerf!==this.props.performanceChart.normal)fe.d.queue=!0,fe.d.minPolylineStep=5,this.prevPerf=!this.prevPerf,this.createChart();else if(this.props.performanceChart.normal||this.prevPerf===this.props.performanceChart.normal){if(this.props.updateData.normal){var e=this.createData();this.chart.data=e[0];var t=e[1];this.range.category=t?0:void 0,this.range.grid.strokeOpacity=t?.7:0}}else fe.d.queue=!1,fe.d.minPolylineStep=.5,this.prevPerf=!this.prevPerf,this.createChart();this.props.toggleUpdateData("normal")}return i.a.createElement(oe,{title:"Normal Probability Distribution Histograms",avatar:i.a.createElement(_e.a,null),expanded:!0},i.a.createElement("div",{className:"stats__chart",ref:"normal_chart"}))}}]),t}(i.a.Component);var xe={toggleUpdateData:M},we=Object(j.b)((function(e){return{mean:e.mean,stDev:e.stDev,samples:e.samples,updateData:e.updateData,performanceChart:e.performanceChart}}),xe)(Ee),ke=a(462);function Me(e){var t=Object(ke.a)((function(t){return{tag:{position:"relative",right:e.right.toString()+"vw",top:e.top.toString()+"vh",height:0}}}))();return i.a.createElement("div",{className:t.tag},i.a.createElement(de.InlineMath,null,"("+e.children+")"))}var Te=function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"stats__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Transforming Random Variable Distributions ",i.a.createElement("br",null)," \xa0"),i.a.createElement(q.a,{variant:"h6",align:"center",gutterBottom:!0},"Normal distributions"),i.a.createElement(q.a,null,"This section compares the performance of an artificially created normal distribution from the uniform distribution provided by Javascript's ",i.a.createElement("code",null,"Math.random()"),"\xa0function. In order to achieve this, a method called the\xa0",i.a.createElement(pe.a,{className:"link",target:"_blank",href:"https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform"},"Box-Muller transform"),"\xa0 was used. If we have two uniformly distributed random variables",i.a.createElement(de.InlineMath,null,"U_1")," and ",i.a.createElement(de.InlineMath,null,"U_2"),", then:",i.a.createElement(de.BlockMath,null,"Z_0 = R \\cos{(\\Theta)}"),i.a.createElement(de.BlockMath,null,"Z_1 = R \\sin{(\\Theta)}"),"where ",i.a.createElement(de.InlineMath,null,"Z_0")," and ",i.a.createElement(de.InlineMath,null,"Z_1")," are normally distributed random variables and",i.a.createElement(de.BlockMath,null,"R^2 = -2 \\ln{U_1}"),i.a.createElement(de.BlockMath,null,"\\Theta = 2\\pi U_2"),"this leads to the final two equations:",i.a.createElement(de.BlockMath,null,"Z_0 = \\sqrt{-2\\ln{U_1}} \\cos{(2\\pi U_2)}"),i.a.createElement(Me,{right:-80,top:-4},"1"),i.a.createElement(de.BlockMath,null,"Z_1 = \\sqrt{-2\\ln{U_1}} \\sin{(2\\pi U_2)}"),i.a.createElement(Me,{right:-80,top:-4},"2"),"In the graph below, we can see its performance in a histogram compared to the analytic function of the normal distribution:",i.a.createElement(de.BlockMath,null,"\\large{\\mathcal{N}(x \\hspace{2pt} ; \\hspace{2pt} \\mu,\\sigma) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}}"),"There is also an option to show the source of the random variable by ticking the 'Uniform' legend which will show raw output from ",i.a.createElement("code",null,"Math.random()"),". The CDF of our transformed distribution is also shown to further our comparison.",i.a.createElement("br",null),"Below the graph, there is a panel that allows you to change the three parameters that define the graph: the mean, variance and number of samples."))),i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(we,null)),i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(ue,null)))},je=function(e){function t(){var e,a;Object(o.a)(this,t);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return(a=Object(m.a)(this,(e=Object(u.a)(t)).call.apply(e,[this].concat(r)))).handleBlur=function(e,t,n){a.props.clip(t,e,n),a.props.toggleUpdateData(n)},a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){var e=this;return i.a.createElement(oe,{title:"Graph Configuration",avatar:i.a.createElement(Y.a,null),expanded:!0},i.a.createElement(P.a,{container:!0},i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement($,{label:"Lambda",name:"poisson",valueName:"lambda",value:this.props.lambda.poisson,inputChange:this.props.inputChange,sliderChange:this.props.sliderChange,toggleUpdateData:this.props.toggleUpdateData,handleBlur:this.handleBlur,max:745,icon:i.a.createElement(Z.a,null)})),i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement($,{label:"Samples",name:"poisson",valueName:"samples",value:this.props.samples.poisson,inputChange:this.props.inputChange,sliderChange:this.props.sliderChange,toggleUpdateData:this.props.toggleUpdateData,handleBlur:this.handleBlur,max:1e6,icon:i.a.createElement(J.a,null)})),i.a.createElement(P.a,{item:!0,xs:6},i.a.createElement(R.a,{component:"fieldset",className:"stats__performance-chart"},i.a.createElement(S.a,null,i.a.createElement(B.a,{control:i.a.createElement(F.a,{checked:this.props.performanceChart.poisson,onChange:function(){return e.props.togglePerformanceChart("poisson")}}),label:"Performance Chart"})),i.a.createElement(L.a,{margin:"dense"},"Tick for faster rendering (recommended at high variances)")))))}}]),t}(i.a.Component);var Ne={sliderChange:x,inputChange:w,clip:k,toggleUpdateData:M,togglePerformanceChart:T},Ie=Object(j.b)((function(e){return{lambda:e.lambda,samples:e.samples,performanceChart:e.performanceChart}}),Ne)(je),Oe=function(e){function t(){var e;return Object(o.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).chart=null,fe.d.commercialLicense=!0,e.prevPerf=!1,e}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){this.createChart()}},{key:"createData",value:function(){var e=this.props.lambda.poisson,t=this.props.samples.poisson,a=z(ve({samples:t,dependent:[{name:"column-1",mean:e,rules:["poisson","positive"]}]})),n=a[0],r=Object.keys(n),i=a[1],s=Object.keys(i).sort((function(e,t){return Number(e)-Number(t)})),l=s.concat(r),o=[],c=[];l.forEach((function(a,r){c=-1===Math.sign(Number(a))?i:n;var s={};s.id=Number(a),s["column-1"]=c[a]["column-1"],s["column-2"]=Math.round(U(e,parseInt(a,10))*t),o[0]?s["column-4"]=o[r-1]["column-4"]+s["column-2"]:s["column-4"]=s["column-2"],o.push(s)}));var m=!1;return 0!==s.length&&(m=!0),[o,m]}},{key:"createChart",value:function(){fe.g(be.a),this.props.performanceChart.poisson?fe.f(ye.a):fe.g(ye.a),this.chart=fe.c(this.refs.poisson_chart,ge.g);var e=this.chart;e.categoryField="category";var t=this.createData();e.data=t[0];var a=t[1],n=e.xAxes.push(new ge.a);n.id="xAxis",n.dataFields.category="id",n.renderer.grid.strokeDasharray=3,this.range=n.axisRanges.create(),this.range.category=a?0:void 0,this.range.label.paddingTop=2,this.range.label.fontSize=12,this.range.grid.stroke=fe.b("grey"),this.range.grid.strokeWidth=1,this.range.grid.strokeOpacity=.7,e.yAxes.push(new ge.f).renderer.grid.strokeDasharray=3;var r=new fe.a,i=e.yAxes.push(new ge.f);i.renderer.grid.template.disabled=!0,i.renderer.line.strokeOpacity=1,i.renderer.line.stroke=r.getIndex(3),i.renderer.line.strokeWidth=2,i.renderer.opposite=!0;var s=e.series.push(this.props.performanceChart.poisson?new ge.e:new ge.b);s.name="Poisson (inverse transform sampling)",s.dataFields.valueY="column-1",s.dataFields.categoryX="id",s.strokeWidth=1,s.fillOpacity=1,s.tensionX=1,this.props.performanceChart.poisson||(s.columns.template.width=fe.e(80),s.fillOpacity=0);var l=e.series.push(new ge.d);l.name="Poisson (analytical)",l.dataFields.valueY="column-2",l.dataFields.categoryX="id",l.strokeWidth=1,l.tensionX=1;var o=e.series.push(new ge.d);o.name="CDF (analytical)",o.dataFields.valueY="column-4",o.dataFields.categoryX="id",o.strokeWidth=1,o.tensionX=1,o.yAxis=i,e.cursor=new ge.h,e.legend=new ge.c;var c=e.legend.markers.template;c.width=12,c.height=12;var m=e.legend.itemContainers.template;m.paddingRight=5,m.paddingLeft=5,m.paddingTop=0,m.paddingBottom=0,e.paddingBottom=20,e.paddingTop=40}},{key:"render",value:function(){if(this.props.updateData.poisson){if(this.props.performanceChart.poisson&&this.prevPerf!==this.props.performanceChart.poisson)fe.d.queue=!0,fe.d.minPolylineStep=5,this.prevPerf=!this.prevPerf,this.createChart();else if(this.props.performanceChart.poisson||this.prevPerf===this.props.performanceChart.poisson){if(this.props.updateData.poisson){var e=this.createData();this.chart.data=e[0];var t=e[1];this.range.category=t?0:void 0,this.range.grid.strokeOpacity=t?.7:0}}else fe.d.queue=!1,fe.d.minPolylineStep=.5,this.prevPerf=!this.prevPerf,this.createChart();this.props.toggleUpdateData("poisson")}return i.a.createElement(oe,{title:"Poisson Probability Distribution Histograms",avatar:i.a.createElement(_e.a,null),expanded:!0},i.a.createElement("div",{className:"stats__chart",ref:"poisson_chart"}))}}]),t}(i.a.Component);var Ce={toggleUpdateData:M},De=Object(j.b)((function(e){return{lambda:e.lambda,samples:e.samples,updateData:e.updateData,performanceChart:e.performanceChart}}),Ce)(Oe);var Pe=function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"stats__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Transforming Random Variable Distributions ",i.a.createElement("br",null)," \xa0"),i.a.createElement(q.a,{variant:"h6",align:"center",gutterBottom:!0},"Poisson distributions"),i.a.createElement(q.a,null,"We now turn to the Poisson distribution, another very prominent distribution that describes random events happening at a constant rate independently of time. The analytic function is:",i.a.createElement(de.BlockMath,null,"\\large{\\text{Po}(x\\hspace{2pt} ; \\hspace{2pt} \\lambda) = \\frac{\\lambda^x}{x!}e^{-\\lambda}}"),"To transform our uniform distribution to a Poisson one, we can use the Knuth algorithm or we can use inverse transform sampling to obtain a practical estimate to the analytic distribution (",i.a.createElement(pe.a,{className:"link",target:"_blank",href:"https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables"},"source"),"). Since the Knuth algorithm can have underflow errors at high ",i.a.createElement(de.InlineMath,null,"\\lambda"),"\xa0 due to the very small ",i.a.createElement(de.InlineMath,null,"e^{\\lambda}"),", another algorithm is also used that uses a smallest value of ",i.a.createElement(de.InlineMath,null,"e^{-\\lambda}")," using a separate parameter \xa0",i.a.createElement(de.InlineMath,null,"{\\footnotesize{\\text{STEP}}}"),"."))),i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(De,null)),i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(Ie,null)))},Re=a(464),Se=a(465),Be=a(466),Fe=a(184),Le=a.n(Fe),qe=a(185),Ae=a.n(qe),He=a(186),Ue=a.n(He),Ge=a(89),We=a.n(Ge),ze=a(187),Xe=a.n(ze),Ve=a(188),$e=a.n(Ve),Ye=a(189),Ze=a.n(Ye),Qe=a(190),Je=a.n(Qe),Ke=a(191),et=a.n(Ke),tt=a(192),at=a.n(tt),nt=a(193),rt=a.n(nt),it=a(171),st=a.n(it),lt=function(e){function t(){return Object(o.a)(this,t),Object(m.a)(this,Object(u.a)(t).call(this))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"stats__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Chapter 1: Neural Encoding I ",i.a.createElement("br",null)," \xa0"),i.a.createElement(oe,{title:"Question 1",avatar:i.a.createElement(Re.a,null),expanded:!1},i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,i.a.createElement("i",null,"Generate spikes for 10 s (or longer if you want better statistics) using a Poisson spike generator with a constant rate of 100 Hz, and record their times of occurrence."),i.a.createElement("br",null),i.a.createElement("br",null),"Estimated probability of firing a spike during a short interval of duration \xa0",i.a.createElement(de.InlineMath,null,"\\Delta t")," is ",i.a.createElement(de.InlineMath,null,"\\text{r}_{\\text{est}}(t)\\Delta t"),"\xa0 where\xa0  ",i.a.createElement(de.InlineMath,null,"\\text{r}_{\\text{est}}(t)"),"\xa0 is the estimate of the firing rate predicted from knowledge of the stimulus (we will assume it is some constant in this first section). The normal way to generate a spike train for this rate is to generate a uniform random number\xa0",i.a.createElement(de.InlineMath,null,"x_{\\text{rand}}")," \xa0 between 0 and 1 at each time step and if \xa0",i.a.createElement(de.InlineMath,null,"\\text{r}_{\\text{est}}(t)\\Delta t > x_{\\text{rand}}"),"\xa0 then a spike is fired in the time step.",i.a.createElement("br",null),i.a.createElement("br",null),"For constant spike rates, we can compute the spike times by using the following iterative formula:",i.a.createElement(de.BlockMath,null,"t_{i+1}=t_i-\\frac{\\ln(x_{\\text{rand}})}{\\text{r}}"),"where \xa0",i.a.createElement(de.InlineMath,null,"\\bf{t}"),"\xa0  is a vector of the spike times. The ISI (interspike intervals) can be computed in one step by taking a vector of random numbers and applying the negative log with the division by \xa0",i.a.createElement(de.InlineMath,null,"\\text{r}"),"\xa0 at once providing a computationally more efficient method. The quantitative comparisons may be found in the extensions section. To record the times of spike occurrence, we use a raster plot and repeat for a number of trials."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def homogeneous_poisson(r, T, n=1, oversample=True):\n    """\n    Generates a homogeneous Poisson spike train of rate r (Hz) and duration T (s) using the vector method\n    :param r: rate\n    :param T: duration\n    :param oversample: whether to include extra samples to make duration equal to T\n    :param n: set number of trials. 1 will return a numpy array, anything larger will return a list of numpy arrays\n    """\n    if n != 1:      # Use recursion to sample multiple trials\n        return [homogeneous_poisson(r, T, n=1, oversample=oversample) for i in range(n)]\n    \n    if oversample:\n        isi = - np.log(np.random.rand(int((r * T) + 3 * np.sqrt(r*T)))) / r  # Oversample by 3 standard deviations\n        t = to_spike_times(isi)     \n        t = t[t<=T]     # Remove spikes that occur after time limit\n    else:\n        isi = - np.log(np.random.rand(r * T)) / r  # Approximately r*T spikes per trial\n        t = to_spike_times(isi)     \n    return t\n\n\ndef homogeneous_poisson_iterative(r, T, n=1):\n    """\n    Generates a homogeneous Poisson spike train of rate r (Hz) and duration T (s) using the iterative formula\n    """\n    if n != 1:      # Use recursion to sample multiple trials\n        return [homogeneous_poisson_iterative(r, T, n=1) for i in range(n)]\n    \n    t = [-np.log(np.random.rand())/r]\n    while True:\n        t.append(t[-1] - np.log(np.random.rand())/r)\n        if t[-1] > T:   # This is python\'s version of a do-while loop\n            t = t[:-1]\n            break\n    return np.array(t)\n\n\ndef to_isi(t, join=False):\n    """\n    Converts spike times to ISI\n    join parameter allows return of numpy vector containing isi from all trials joined together\n    """\n    if type(t) == list:     # case of multiple trials\n        isi = [i[1:] - i[:-1].copy() for i in t]\n        if join:\n            return np.array(list(itertools.chain(*isi)))\n        else:\n            return isi\n    else:                   # case of single trial\n        isi = t.copy()\n        isi[1:] -= isi[:-1].copy()  # inverse of cumsum\n        return isi  \n\n\ndef to_spike_times(isi):\n    """\n    Converts ISI to spike times\n    """\n    if type(isi) == list:   # case of multiple trials\n        return np.cumsum(isi, axis=1)\n    else:                   # case of single trial\n        return np.cumsum(isi)\n\ndef plot_spikes(t, T=np.inf):\n    """\n    Raster plot for one or more spike trains\n    :param t: spike times\n    :param T: integer for cropping to a set duration (default set to infinity for no cropping)\n    """\n    if type(t) == list:\n        n = len(t)\n        t = [t[i][t[i]<=T] for i in range(n)]\n        line_size = [0.6 for i in range(n)]\n        colours = [\'C{}\'.format(i) for i in range(n)]\n        plt.eventplot(t, linelengths=line_size, colors=colours)\n    elif t.ndim == 1:\n        t = t[t<=T]\n'+"        plt.eventplot(t, linelengths=0.6, color=plt.rcParams['axes.prop_cycle'].by_key()['color'][0])\n    plt.title('Spike trains')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Spike occurrence')\n\n\nt = homogeneous_poisson(100, 10, n=10)\nplot_spikes(t, T=0.5)"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Le.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Ze.a,className:"neur__questions__image"}))))),i.a.createElement("hr",{className:"neur__hr"}),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,i.a.createElement("i",null,"Compute the coefficient of variation of the interspike intervals, and the Fano factor for spike counts obtained over counting intervals ranging from 1 to 100 ms. Plot the interspike interval histogram."),i.a.createElement("br",null),"The coefficient of variation is defined as:",i.a.createElement(de.BlockMath,null,"C_V=\\frac{\\sigma_{\\tau}}{\\langle\\tau\\rangle}"),"where",i.a.createElement(de.BlockMath,null,"\\begin{aligned}\n\\langle\\tau\\rangle &= \\int^{\\infty}_0 \\tau \\text{p}_{\\tau}[\\tau] \\text{d}\\tau = \\frac{1}{\\text{r}}\\\\\n\\sigma_{\\tau}^2 &= \\int^{\\infty}_0\\tau^2\\text{p}_{\\tau}[\\tau] \\text{d}\\tau - \\langle\\tau\\rangle^2 = \\frac{1}{\\text{r}^2}\n\\end{aligned}"),"using the fact that ISI (represented by ",i.a.createElement(de.InlineMath,null,"\\tau"),") are distributed according to an exponential distribution (explanation for this in extensions section).",i.a.createElement("br",null),i.a.createElement("br",null),"The Fano factor is defined as:",i.a.createElement(de.BlockMath,null,"F = \\frac{\\sigma_n^2}{\\langle n\\rangle}"),"where",i.a.createElement(de.BlockMath,null,"\\begin{aligned}\n\\langle n\\rangle &= \\sum^{\\infty}_{n=0} n\\text{P}_{N}[n] = \\text{r}T\\\\\n\\sigma_n^2 &= \\Big(\\sum^{\\infty}_{n=0}n^2\\text{P}_{N}[n]\\Big) - \\langle n\\rangle^2 = \\text{r}T\n\\end{aligned}"),"using the fact that spike times (represented by ",i.a.createElement(de.InlineMath,null,"n"),") are distributed according to a Poisson distribution (explanation for this in extensions section).",i.a.createElement("br",null),i.a.createElement("br",null),"The theoretical values of both of these metrics are 1 for a homogeneous Poisson process independent of ",i.a.createElement(de.InlineMath,null,"T"),".",i.a.createElement("br",null),"We can confirm these values by plotting the mean and variance against each other. We should see that these points lie on the x=y line."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def fano_factor(t, window, end, start=0, return_value=True):\n    """\n    Computes the Fano factor\n    :param t: spike times\n    :param start: start time of sampling (if the whole spike train is not to be taken account for)\n    :param end: end time of sampling     (if the whole spike train is to be considered, enter the duration of the spike train here)\n    :param window: window size for averaging ()\n    :param return_value: set to False if the individual values of the variance and mean are required\n    """\n    if type(t) == list:\n        n = np.array([]) if return_value else np.array([[None, None]])\n        for trial in t:\n                if return_value:\n                    n = np.concatenate((n, fano_factor(trial, window, end, start=start, return_value=\'recurse\')))\n                else:\n                    n = np.concatenate((n, np.array([fano_factor(trial, window, end, start=start, return_value=False)])))\n    else:\n        n = bin_spikes(t, window, start, end)[0]\n\n    if return_value == \'recurse\':\n        return n\n    elif return_value:\n        return np.var(n) / np.mean(n)\n    else:\n        if type(t) == list:\n            return n[1:].T\n        else:\n            return np.var(n), np.mean(n)\n\n\ndef coefficient_variation(t, return_value=True):\n    """\n    Computes the coefficient of variation of a given spike train\n    If return_value is set to false, will return the variance and mean as a tuple\n    """\n    if type(t) == list:\n        isi = np.array([]) if return_value else np.array([[None, None]])\n        for trial in t:\n                if return_value:\n                    isi = np.concatenate((isi, coefficient_variation(trial, return_value=\'recurse\')))\n                else:\n                    isi = np.concatenate((isi, np.array([coefficient_variation(trial, return_value=False)])))\n    else:\n        isi = to_isi(t)\n\n    if return_value == \'recurse\':\n        return isi\n    elif return_value:\n        return np.std(isi) / np.mean(isi)\n    else:\n        if type(t) == list:\n            return isi[1:].T\n        else:\n            return np.std(isi), np.mean(isi)\n\n\ndef bin_spikes(t, window, start, end):\n    """\n    Returns histogram counts of the spikes from start to end (in seconds) in with a bin width of window\n    Discards some of the last data if the interval does not divide exactly into window\n    """\n    cropped_end = end - (end - start) % window                      # Makes sure that the specified interval divides into bins of duration window\n    number_bins = int((cropped_end - start) / window)\n    bins = np.linspace(start, cropped_end, number_bins+1)           # Acts like np.arange but including the last element (more stable with floats)\n    return np.histogram(t, bins)                                    # number of spikes in each bin\n\n\ndef plot_interval_hist(t, c=0, fill=False, alpha=1, label=None, line_plot=False, density=False, extra_title=\'\'):\n    """\n    Plots a histogram of the ISI (c sets colour index)\n    """\n    isi = to_isi(t, join=True)\n    plt.hist(isi*1000, bins=50, fill=fill,\n'+"             edgecolor=plt.rcParams['axes.prop_cycle'].by_key()['color'][c],\n             facecolor=plt.rcParams['axes.prop_cycle'].by_key()['color'][c], alpha=alpha, label=label, density=density)\n    if line_plot:\n        plt.plot(np.histogram(isi, bins=50)[1][:-1]*1000, np.histogram(isi, bins=50)[0], color=plt.rcParams['axes.prop_cycle'].by_key()['color'][c])\n    plt.title('Interspike interval histogram' + extra_title)\n    plt.xlabel('Interval (ms)')\n    plt.ylabel('Histogram count')\n\ndef diagonal_fit_plot(x):\n    \"\"\"\n    Takes in a tuple of (x, y) data and plots it against a x=y diagonal\n    \"\"\"\n    plt.scatter(x[0], x[1], marker='.', color='gray', label='data')\n    plt.plot([x.min(), x.max()], [x.min(), x.max()], color='red', label='fit')\n    plt.legend()\n\n\ndef join_lists(x):\n    \"\"\"\n    Used for running multiple trial sets with different hyperparameters\n    Joins the lists of numpy arrays into one large list of numpy arrays\n    \"\"\"\n    return list(itertools.chain(*x))\n\nt = homogeneous_poisson(100, 50, 10)\nwindows = np.linspace(1, 100, 100) / 1000\nF = [fano_factor(t, i, 50) for i in windows]\nplt.scatter(1000*windows, F)\nplt.xlabel('Window size (ms)')\nplt.ylabel('Fano factor')\nplt.title('Fano factor for different window sizes')\nplt.show()\n\nCv = coefficient_variation(t)\nprint('Coefficient of variation: ' + str(Cv))\n\nplot_interval_hist(t)\nplt.show()\n\nrates = np.linspace(10, 100, 91, dtype=int)\nt = join_lists([homogeneous_poisson(i, 10, 50) for i in rates])\nF = fano_factor(t, 1e-3, 10, return_value=False)\ndiagonal_fit_plot(F)\nplt.xlabel('Spike Count Variance')\nplt.ylabel('Spike Count Mean')\nplt.title('Fano factor')\nplt.show()\n\nCv = coefficient_variation(t, return_value=False)\ndiagonal_fit_plot(Cv)\nplt.xlabel('Interval Standard Deviation')\nplt.ylabel('Interval Mean')\nplt.title('Coefficient of variation')\nplt.show()"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Ae.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Ue.a,className:"neur__questions__image"}))),i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Xe.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:$e.a,className:"neur__questions__image"})))))),i.a.createElement(oe,{title:"Question 2",avatar:i.a.createElement(Re.a,null),expanded:!1},i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,i.a.createElement("i",null,"Add a refractory period to the Poisson spike generator by allowing the firing rate to depend on time. Initially, set the firing rate to a constant value, ",i.a.createElement(de.InlineMath,null,"\\text{r}(t) = \\text{r}_0"),". After every spike, set \xa0",i.a.createElement(de.InlineMath,null,"\\text{r}(t)")," to 0, and then allow it to recover exponentially back to ",i.a.createElement(de.InlineMath,null,"\\text{r}_0")," with a time constant \xa0",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," that controls the refractory recovery rate. In other words, have ",i.a.createElement(de.InlineMath,null,"\\text{r}(t)")," obey the equation",i.a.createElement(de.BlockMath,null,"\\tau_{\\text{ref}}\\frac{\\text{dr}}{\\text{d}t}=\\text{r}_0-\\text{r}"),"except immediately after a spike, when it is set to 0."),i.a.createElement("br",null),i.a.createElement("br",null),"Solving this ODE with an initial condition of zero at t=0, we get the following:",i.a.createElement(de.BlockMath,null,"\\text{r}(t) = \\text{r}_0(1-e^{-\\frac{t}{\\tau_{\\text{ref}}}})"),"The way we will implement this is through rejection sampling. We will first take a spike train formed by the homogeneous Poisson process and then for each spike, reject it if \xa0",i.a.createElement(de.InlineMath,null,"\\frac{\\text{r}(t_i)}{\\text{r}_0} < x_{\\text{rand}}")," where \xa0",i.a.createElement(de.InlineMath,null,"x_{\\text{rand}}")," is a random uniform variable as before and ",i.a.createElement(de.InlineMath,null,"t_i")," are the spike times."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def refractory_period(t, r0, tau):\n    """\n    Function that returns the exponential decay model for the refractory period with an initial condition of 0 at t=0\n    """\n    return r0 * (1 - np.exp(-t / tau))\n\n\ndef refractory_homogeneous_poisson(r0, T, tau, n=1):\n    """\n    Generates a homogeneous Poisson spike train with a refractory period (time constant tau), rate r (Hz) and duration T (s) using rejection sampling\n    :param r: rate\n    :param T: duration\n    :param tau: time constant for exponential decay model of refractory period\n    :param n: set number of trials. 1 will return a numpy array, anything larger will return a list of numpy arrays\n    """\n    if n != 1:          # Use recursion to sample multiple trials\n        return [refractory_homogeneous_poisson(r0, T, tau, n=1) for i in range(n)]\n    else:\n        t = homogeneous_poisson(r0, T)\n        retained_indices = [0]\n        for i in range(t.shape[0]-1):                           # Loop over all spikes\n            xrand = np.random.rand()                            \n            rt = refractory_period(t[i+1] - t[retained_indices[-1]], r0, tau)\n            if rt/r0 > xrand:                                   # Rejection sampling\n                retained_indices.append(i+1)\n        return t[retained_indices]\n    """\n    Below is a very fast, vectorised way of rejection sampling. However, it will not be used since it treats all spikes at once and so will\n    delete too many spikes\n    else:\n        t = homogeneous_poisson(r0, T)\n        isi = to_isi(t)[1:]                                     # Exclude first spike since it can never be in a refractory period\n        rt = refractory_period(isi, r0, tau)                    # Get values for r(t) at each spike\n        xrand = np.random.rand(rt.shape[0])                     # Random variables for rejection sampling\n        retained_indices = np.where(rt/r0 > xrand)[0] + 1       # Rejection sampling (+1 to account for first spike)\n        retained_indices = np.insert(retained_indices, 0, 0)    # Add back the first spike (index 0)\n        retained_spikes = t[retained_indices]\n        return retained_spikes\n    """\n\nt = refractory_homogeneous_poisson(100, 10, 0.01, n=100)\nplot_spikes(t, T=1)\nplt.show()\nplot_interval_hist(t)\nplt.title(r\'Interspike interval histogram $\\displaystyle\\tau_{\\text{ref}} = 10ms$\')\nplt.show()'))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Je.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:et.a,className:"neur__questions__image"}))))),i.a.createElement("hr",{className:"neur__hr"}),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,i.a.createElement("i",null,"Plot the coeffcient of variation as a function of ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," over the range 1 ms \xa0",i.a.createElement(de.InlineMath,null,"\\leq \\tau_{\\text{ref}} \\leq")," 20 ms, and plot interspike interval histograms for a few different values of \xa0",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," in this range."),i.a.createElement("br",null),i.a.createElement("br",null),"The coefficient of variation decreases as the value of ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," is increased. This makes sense because the larger the value of ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}"),", the further our model is from an exponential distribution as seen by the deviation of the coefficient of variation.",i.a.createElement("br",null),"This is further confirmed by looking at the interspike interval histogram which shows us that the distribution is no longer just exponential: it now has the shape of a Poisson distribution but on closer inspection of the mean and variances, we see that the distribution is not exactly Poisson (mean and variance do not equal). ",i.a.createElement("br",null),i.a.createElement("br",null),"A description of modelling this distribution if found in the extensions section."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},"taus = np.linspace(1, 20, 50) / 1000\nCv = [coefficient_variation(refractory_homogeneous_poisson(100, 10, i, 5)) for i in taus]\nplt.scatter(taus, Cv)\nplt.xlabel(r'$\\displaystyle\\tau_{\\text{ref}} (ms)$')\nplt.ylabel('Coefficient of variation')\nplt.show()\n\nt = refractory_homogeneous_poisson(100, 1000, 1e-3, 1)\nplot_interval_hist(t, 0, True, 0.33, r'$\\displaystyle\\tau_{\\text{ref}} = 1ms$')\n\nt = refractory_homogeneous_poisson(100, 1000, 1e-2, 1)\nplot_interval_hist(t, 1, True, 0.33, r'$\\displaystyle\\tau_{\\text{ref}} = 10ms$')\n\n\nt = refractory_homogeneous_poisson(100, 1000, 1e-1, 1)\nplot_interval_hist(t, 2, True, 0.33, r'$\\displaystyle\\tau_{\\text{ref}} = 100ms$')\n\nplt.legend()"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:at.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:rt.a,className:"neur__questions__image"}))))),i.a.createElement("hr",{className:"neur__hr"}),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,i.a.createElement("i",null,"Compute the Fano factor for spike counts obtained over counting intervals ranging from 1 to 100 ms for the case ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," = 10 ms."),i.a.createElement("br",null),i.a.createElement("br",null),"As compared to question 1, the Fano factor rapidly decays away from 1 as the window size increases which is not seen for the homogeneous Poisson spike generator. This is an expected result since larger windows capture the effect of the refractory period better, straying further from the homogeneous Poisson results where the Fano factor is 1."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},"t = refractory_homogeneous_poisson(100, 50, 1e-2, 10)\nwindows = np.linspace(1, 100, 100) / 1000\nF = [fano_factor(t, i, 50) for i in windows]\nplt.scatter(1000*windows, F)\nplt.xlabel('Window size (ms)')\nplt.ylabel('Fano factor')\nplt.title('Fano factor for different window sizes')\nplt.show()"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:st.a,className:"neur__questions__image"})))))))),i.a.createElement(P.a,{item:!0,xs:12}))}}]),t}(i.a.Component),ot=function(e){function t(){return Object(o.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"stats__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Google Colab notebooks: ",i.a.createElement("br",null)," ",i.a.createElement("br",null)),i.a.createElement(q.a,{variant:"h6",align:"center",gutterBottom:!0},i.a.createElement(pe.a,{className:"link",target:"_blank",href:"http://bit.ly/2MLMApR"},"Gradient descent and Backpropagation"),i.a.createElement("br",null),i.a.createElement(pe.a,{className:"link",target:"_blank",href:"http://bit.ly/2METBIW"},"Regularisation and Cross-Entropy"),i.a.createElement("br",null),i.a.createElement(pe.a,{className:"link",target:"_blank",href:"http://bit.ly/2QG9HnC"},"k-means Clustering")))))}}]),t}(i.a.Component),ct=a(50),mt=function(e){function t(e){var a;return Object(o.a)(this,t),(a=Object(m.a)(this,Object(u.a)(t).call(this,e))).recursiveReflection=function(e,t,n){if(0===n)return 1;for(var r=[],i=0;i<a.objects.length;i++){for(var s=1;s<a.objects[i].length;s++)r.push(a.calculateIntersect(e,t,a.objects[i][s-1],a.objects[i][s]));a.objects[i].length>2&&r.push(a.calculateIntersect(e,t,a.objects[i][a.objects[i].length-1],a.objects[i][0]))}if(a.frame.length>0){for(var l=1;l<a.frame.length;l++)r.push(a.calculateIntersect(e,t,a.frame[l-1],a.frame[l]));r.push(a.calculateIntersect(e,t,a.frame[a.frame.length-1],a.frame[0]))}for(var o=1e8,c=-1,m=0,u=0;u<r.length;u++)r[u]&&(m=r[u].vMinus(e).l22)<o&&(c=u,o=m);if(c>=0){a.drawLine(e,r[c]),a.numberOfRays++;var h=new V(null,null);(h=c>=a.normals.length?a.frame_normals[c-a.normals.length]:a.normals[c])||(h=a.frame_normals[c-a.normals.length-1]),a.drawCircle(r[c],4);var p=a.reflect(r[c].vMinus(e),h).vPlus(r[c]);if(a.shootMode){if(setTimeout((function(){a.recursiveReflection(r[c],p,n-1)}),a.state.shootDelay),a.refraction){var d=a.refract(r[c].vMinus(e),h,a.state.refractiveIndex).vPlus(r[c]);setTimeout((function(){a.recursiveReflection(r[c],d,n-1)}),a.state.shootDelay)}}else if(a.recursiveReflection(r[c],p,n-1),a.refraction){var f=a.refract(r[c].vMinus(e),h,a.state.refractiveIndex).vPlus(r[c]);a.recursiveReflection(r[c],f,n-1)}}},a.clicked=function(e){var t=a.cvs.getBoundingClientRect();if(a.addMode||a.polyDraw)if(a.polyDraw){var n,r=a.drawPolygon(new V(e.x-t.left,e.y-t.top),a.polyRadius,a.polyN,a.polyAngle,!0);a.objects.push(r[0]),(n=a.normals).push.apply(n,Object(ct.a)(r[1])),a.objectsText.innerHTML="Number of objects: "+a.objects.length.toString()+" (press 'a' to add object edges)",a.edgesText.innerHTML="Number of edges: "+a.normals.length.toString()}else a.addedFirstVertex||(a.objects.push([]),a.addedFirstVertex=!0),a.objects[a.objects.length-1].push(new V(e.x-t.left,e.y-t.top)),a.objects[a.objects.length-1].length>1&&(a.normals.push(a.calculateNormal(a.objects[a.objects.length-1][a.objects[a.objects.length-1].length-1],a.objects[a.objects.length-1][a.objects[a.objects.length-1].length-2])),a.edgesText.innerHTML="Number of edges: "+a.normals.length.toString()),a.draw();else a.source.set(e.x-t.left,e.y-t.top),a.draw()},a.onScroll=function(e){a.polyDraw&&(3===a.polyN&&e.deltaY>0||(a.polyN-=e.deltaY/100,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off"),a.draw())),a.multiRayMode&&(1===a.multiRayN&&e.deltaY>0||(a.multiRayN-=e.deltaY/100,a.multiRayText.innerHTML="Multi-ray mode (M): "+(a.multiRayMode?"On (N:"+a.multiRayN.toString()+", scroll)":"Off"),a.draw()))},a.onMouseMove=function(e){if(!a.addMode||a.polyDraw){var t=a.cvs.getBoundingClientRect();a.view.set(e.x-t.left,e.y-t.top),a.shootMode||a.draw()}},a.addObject=function(e){65===e.keyCode&&(a.addMode=!a.addMode,a.addMode&&(a.addedFirstVertex=!1,a.draw()),a.addMode||(a.objects.length>0&&(a.objects[a.objects.length-1].length>2?(a.normals.push(a.calculateNormal(a.objects[a.objects.length-1][0],a.objects[a.objects.length-1][a.objects[a.objects.length-1].length-1])),a.edgesText.innerHTML="Number of edges: "+a.normals.length.toString(),a.objectsText.innerHTML="Number of objects: "+a.objects.length.toString()+" (press 'a' to add object edges)"):2===a.objects[a.objects.length-1].length?a.objectsText.innerHTML="Number of objects: "+a.objects.length.toString()+" (press 'a' to add object edges)":a.objects.pop()),a.draw())),70===e.keyCode&&(a.frame_on?(a.frame=[],a.frame_normals=[]):(a.frame.push(new V(0,0),new V(0,a.cvs.height),new V(a.cvs.width,a.cvs.height),new V(a.cvs.width,0)),a.frame_normals.push(new V(1,0),new V(0,1),new V(-1,0),new V(0,-1))),a.frame_on=!a.frame_on,a.frameText.innerHTML="Frame (F): "+(a.frame_on?"On":"Off"),a.draw()),37===e.keyCode&&(a.polyDraw&&(a.polyAngle-=Math.PI/16,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off")),a.draw()),38===e.keyCode&&(a.polyDraw?(a.polyRadius+=10,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off")):(a.recursionDepth++,a.recursionDepthText.innerHTML="Recursion depth: "+a.recursionDepth.toString()+" (use arrow keys to change)"),a.draw()),39===e.keyCode&&(a.polyDraw&&(a.polyAngle+=Math.PI/16,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off")),a.draw()),40===e.keyCode&&(a.polyDraw?a.polyRadius>=20&&(a.polyRadius-=10,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off")):1!==a.recursionDepth&&(a.recursionDepth--,a.recursionDepthText.innerHTML="Recursion depth: "+a.recursionDepth.toString()+" (use arrow keys to change)"),a.draw()),82===e.keyCode&&(a.polyDraw?(a.polyRadius=50,a.polyN=8,a.polyAngle=0,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off")):(a.recursionDepth=3,a.recursionDepthText.innerHTML="Recursion depth: "+a.recursionDepth.toString()+" (use arrow keys to change)",a.multiRayN=12,a.multiRayText.innerHTML="Multi-ray mode (M): "+(a.multiRayMode?"On (N:"+a.multiRayN.toString()+", scroll)":"Off")),a.draw()),67===e.keyCode&&(a.objects=[],a.normals=[],a.objectsText.innerHTML="Number of objects: "+a.objects.length.toString()+" (press 'a' to add object edges)",a.edgesText.innerHTML="Number of edges: "+a.normals.length.toString(),a.draw()),84===e.keyCode&&(a.refraction=!a.refraction,a.refractionText.innerHTML="Refraction (T): "+(a.refraction?"On":"Off"),a.draw()),83===e.keyCode&&(a.showNormals=!a.showNormals,a.normalsText.innerHTML="Surface normals (S): "+(a.showNormals?"On":"Off"),!a.addMode||a.objects.length>0&&a.objects[a.objects.length-1].length>0||(a.objects.pop(),a.popped=!a.popped),a.draw()),80===e.keyCode&&(a.polyDraw=!a.polyDraw,a.polyDrawText.innerHTML="Polygon draw mode (P): "+(a.polyDraw?"On (N="+a.polyN.toString()+", R="+a.polyRadius.toString()+", \u03b8="+a.round(a.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0, scroll/arrow keys)":"Off"),a.draw()),77===e.keyCode&&(a.multiRayMode=!a.multiRayMode,a.multiRayText.innerHTML="Multi-ray mode (M): "+(a.multiRayMode?"On (N:"+a.multiRayN.toString()+", scroll)":"Off"),a.draw()),81===e.keyCode&&(a.shootMode=!a.shootMode,a.shootModeText.innerHTML="Shoot mode (Q): "+(a.shootMode?"On":"Off"),a.draw()),32===e.keyCode&&a.shootMode&&a.draw()},a.state={refractiveIndex:1.33,shootDelay:300},a.source=new V(null,null),a.view=new V(null,null),a.addMode=!1,a.objects=[],a.normals=[],a.frame_on=!0,a.dist=0,a.recursionDepth=3,a.numberOfRays=0,a.refraction=!0,a.showNormals=!1,a.popped=!1,a.polyDraw=!1,a.addedFirstVertex=!1,a.multiRayMode=!1,a.polyRadius=50,a.polyN=8,a.polyAngle=0,a.multiRayN=12,a.shootMode=!1,a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){this.cvs=document.getElementById("canvas"),this.ctx=this.cvs.getContext("2d"),this.frame=[new V(0,0),new V(0,this.cvs.height),new V(this.cvs.width,this.cvs.height),new V(this.cvs.width,0)],this.frame_normals=[new V(1,0),new V(0,1),new V(-1,0),new V(0,-1)],this.cvs.addEventListener("mousedown",this.clicked),this.cvs.addEventListener("mousemove",this.onMouseMove),document.addEventListener("keydown",this.addObject),document.addEventListener("wheel",this.onScroll),this.recursionDepthText=document.getElementById("recursionDepth"),this.objectsText=document.getElementById("objects"),this.edgesText=document.getElementById("edges"),this.frameText=document.getElementById("frame"),this.raysText=document.getElementById("rays"),this.refractionText=document.getElementById("refraction"),this.normalsText=document.getElementById("normals"),this.polyDrawText=document.getElementById("polyDraw"),this.multiRayText=document.getElementById("multiRay"),this.shootModeText=document.getElementById("shootMode"),this.recursionDepthText.innerHTML="Recursion depth: "+this.recursionDepth.toString()+" (use arrow keys to change)",this.objectsText.innerHTML="Number of objects: "+this.objects.length.toString()+" (press 'a' to add object edges)",this.edgesText.innerHTML="Number of edges: "+this.normals.length.toString(),this.frameText.innerHTML="Frame (F): "+(this.frame_on?"On":"Off"),this.raysText.innerHTML="Number of rays: "+this.numberOfRays.toString(),this.refractionText.innerHTML="Refraction (T): "+(this.refraction?"On":"Off"),this.normalsText.innerHTML="Surface normals (S): "+(this.showNormals?"On":"Off"),this.polyDrawText.innerHTML="Polygon draw mode (P): "+(this.polyDraw?"On (N="+this.polyN.toString()+", R="+this.polyRadius.toString()+", \u03b8="+this.round(this.polyAngle*(180/Math.PI)%360,3).toString()+"\xb0)":"Off"),this.multiRayText.innerHTML="Multi-ray mode (M): "+(this.multiRayMode?"On (N:"+this.multiRayN.toString()+")":"Off"),this.shootModeText.innerHTML="Shoot mode (Q): "+(this.shootMode?"On":"Off")}},{key:"calculateIntersect",value:function(e,t,a,n){var r=t.vMinus(e),i=a.vMinus(e),s=n.vMinus(a),l=this.round((r.y*i.x-r.x*i.y)/(r.x*s.y-r.y*s.x),5),o=0;if(o=0===r.y?this.round((i.x+s.x*l)/r.x,5):this.round((i.y+s.y*l)/r.y,5),l<=1&&l>=0&&o>0)return a.vPlus(s.mult(l))}},{key:"round",value:function(e,t){return Math.round(e*Math.pow(10,t))/Math.pow(10,t)}},{key:"reflect",value:function(e,t){return e.vMinus(t.mult(2*e.dot(t)))}},{key:"refract",value:function(e,t,a){e.normalise();var n=Math.min(Math.max(e.dot(t),-1),1),r=1,i=a,s=t;if(n<0)n=-n;else{var l=r;r=i,i=l,s=t.mult(-1)}var o=r/i,c=1-o*o*(1-n*n);return c<=0?new V(0,0):e.mult(o).vPlus(s.mult(o*n-Math.sqrt(c)))}},{key:"drawLine",value:function(e,t){var a,n;this.ctx.beginPath(),(a=this.ctx).moveTo.apply(a,Object(ct.a)(e.p)),(n=this.ctx).lineTo.apply(n,Object(ct.a)(t.p)),this.ctx.closePath(),this.ctx.strokeStyle="rgb(255, 255, 255)",this.ctx.stroke()}},{key:"drawCircle",value:function(e,t){var a;this.ctx.beginPath(),(a=this.ctx).arc.apply(a,Object(ct.a)(e.p).concat([t,0,2*Math.PI])),this.ctx.fillStyle="rgb(0, 0, 255)",this.ctx.fill()}},{key:"drawArrow",value:function(e,t,a){var n,r,i,s,l;(n=this.ctx).moveTo.apply(n,Object(ct.a)(e.p)),t.normalise();var o=(t=t.mult(a)).vPlus(e);(r=this.ctx).lineTo.apply(r,Object(ct.a)(o.p));var c=Math.atan2(o.y-e.y,o.x-e.x),m=new V(Math.cos(c+Math.PI/6),Math.sin(c+Math.PI/6)).mult(a/5),u=new V(Math.cos(c-Math.PI/6),Math.sin(c-Math.PI/6)).mult(a/5);(i=this.ctx).lineTo.apply(i,Object(ct.a)(o.vMinus(m).p)),(s=this.ctx).moveTo.apply(s,Object(ct.a)(o.p)),(l=this.ctx).lineTo.apply(l,Object(ct.a)(o.vMinus(u).p))}},{key:"drawPolygon",value:function(e,t,a,n,r){this.ctx.beginPath();var i=Math.PI*(2/a),s=2*t*Math.sin(n/2),l=Math.PI/8-n/2,o=2*t*Math.sin(i/2),c=e.x-o/2+s*Math.cos(l),m=e.y-t-s*Math.sin(l),u=[new V(c,m)],h=[];this.ctx.moveTo(c,m);for(var p=0;p<a-1;p++)c+=o*Math.cos(p*i+n),m+=o*Math.sin(p*i+n),r?(u.push(new V(c,m)),h.push(this.calculateNormal(u[u.length-2],u[u.length-1]))):this.ctx.lineTo(c,m);if(this.ctx.closePath(),this.ctx.stroke(),r)return h.push(this.calculateNormal(u[u.length-1],u[0])),[u,h]}},{key:"calculateNormal",value:function(e,t){var a=t.vMinus(e),n=new V(a.y,-a.x);return n.normalise(),n}},{key:"draw_border",value:function(){if(this.ctx.clearRect(0,0,this.cvs.width,this.cvs.height),this.frame.length>0){var e;this.ctx.beginPath(),(e=this.ctx).moveTo.apply(e,Object(ct.a)(this.frame[0].p));for(var t=1;t<this.frame.length;t++){var a;(a=this.ctx).lineTo.apply(a,Object(ct.a)(this.frame[t].p))}this.ctx.closePath(),this.ctx.strokeStyle="rgb(255, 0, 0)",this.ctx.lineWidth=4,this.ctx.stroke(),this.ctx.strokeStyle="rgb(0, 0, 0)",this.ctx.lineWidth=1}else this.ctx.lineWidth=4,this.ctx.strokeStyle="rgb(255, 255, 255)",this.ctx.strokeRect(0,0,this.cvs.width,this.cvs.height),this.ctx.lineWidth=1}},{key:"drawNormals",value:function(){var e=0;this.ctx.beginPath();for(var t=0;t<this.objects.length;t++){for(var a=1;a<this.objects[t].length;a++)this.drawArrow(this.objects[t][a].vPlus(this.objects[t][a-1]).mult(.5),this.normals[e],30),e++;this.objects[t].length>2&&(this.normals[e]?this.drawArrow(this.objects[t][0].vPlus(this.objects[t][this.objects[t].length-1]).mult(.5),this.normals[e],30):this.drawArrow(this.objects[t][0].vPlus(this.objects[t][this.objects[t].length-1]).mult(.5),this.calculateNormal(this.objects[t][0],this.objects[t][this.objects[t].length-1]),30),e++)}this.ctx.closePath(),this.ctx.strokeStyle="rgb(255, 255, 255)",this.ctx.stroke()}},{key:"drawObjects",value:function(){if(this.objects.length>0&&this.objects[this.objects.length-1].length>0)for(var e=0;e<this.objects.length;e++){var t;this.ctx.beginPath(),(t=this.ctx).moveTo.apply(t,Object(ct.a)(this.objects[e][0].p));for(var a=1;a<this.objects[e].length;a++){var n;(n=this.ctx).lineTo.apply(n,Object(ct.a)(this.objects[e][a].p))}this.ctx.closePath(),this.ctx.strokeStyle="rgb(255, 255, 255)",this.ctx.stroke(),this.refraction&&(this.ctx.fillStyle="rgba(255,148,0,0.38)",this.ctx.fill())}}},{key:"drawMultiRays",value:function(){for(var e=new V(0,0),t=Math.PI*(2/this.multiRayN),a=0;a<this.multiRayN;a++)e=new V(this.round(Math.sin(a*t),4),-this.round(Math.cos(a*t),4)),this.recursiveReflection(this.view,this.view.vPlus(e),this.recursionDepth)}},{key:"draw",value:function(){this.draw_border(),this.numberOfRays=0,this.addMode&&(this.ctx.fillStyle="rgb(0, 0, 255, 0.2)",this.ctx.fillRect(2,2,this.cvs.width-4,this.cvs.height-4)),this.multiRayMode||this.drawCircle(this.source,3),this.polyDraw&&this.drawPolygon(this.view,this.polyRadius,this.polyN,this.polyAngle,!1),this.drawObjects(),this.showNormals&&this.drawNormals(),this.popped&&(this.objects.push([]),this.popped=!this.popped),this.polyDraw||(this.multiRayMode?this.drawMultiRays():this.recursiveReflection(this.source,this.view,this.recursionDepth)),this.raysText.innerHTML="Number of rays: "+this.numberOfRays.toString()}},{key:"render",value:function(){var e=this;return i.a.createElement(he.a,{className:"rayPaper"},i.a.createElement("div",{style:{height:"5em"}}),i.a.createElement("canvas",{id:"canvas",width:.99*window.innerWidth,height:.73*window.innerHeight}),i.a.createElement("section",{className:"info"},i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"rtcard",id:"recursionDepth"}),i.a.createElement("div",{className:"rtcard",id:"objects"}),i.a.createElement("div",{className:"rtcard",id:"edges"})),i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"rtcard",id:"frame"}),i.a.createElement("div",{className:"rtcard",id:"refraction"}),i.a.createElement("div",{className:"rtcard",id:"normals"})),i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"rtcard",id:"polyDraw"}),i.a.createElement("div",{className:"refr"},i.a.createElement("label",{htmlFor:"refractiveIndex"},"Refractive index: "),i.a.createElement("input",{value:this.state.refractiveIndex,placeholder:"1.33",id:"refractiveIndex",onChange:function(t){e.setState({refractiveIndex:t.target.value})}})),i.a.createElement("div",{className:"rtcard",id:"rays"})),i.a.createElement("div",{className:"row"},i.a.createElement("div",{className:"rtcard",id:"multiRay"}),i.a.createElement("div",{className:"refr"},i.a.createElement("div",{id:"shootMode"}),i.a.createElement("input",{value:this.state.shootDelay,placeholder:"300",id:"shootDelay",onChange:function(t){e.setState({shootDelay:t.target.value})}})))))}}]),t}(i.a.Component),ut=a(172),ht=a.n(ut),pt=function(e){function t(){var e;return Object(o.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).chart=null,fe.d.commercialLicense=!0,e}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"neur__info__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Theoretical Neuroscience ",i.a.createElement("br",null)," \xa0"),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__info__grid"},i.a.createElement(Be.a,{image:ht.a,className:"neur__info__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__info__grid"},i.a.createElement(q.a,{gutterBottom:!0},"This section will go through the \xa0",i.a.createElement(pe.a,{className:"link",target:"_blank",href:"https://www.gatsby.ucl.ac.uk/~dayan/book/exercises/"},"problems"),"\xa0 chapter by chapter from Peter Dayan and L. F. Abbott's Theoretical neuroscience textbook. The solutions are computed in python, there will be code snippets along with the answers. The accompanying graphs are saved from matplotlib plots. The reason python was used over javascript is due to it's fast and wide linear algebra modules such as numpy."),i.a.createElement(q.a,{gutterBottom:!0},"For certain questions, there might be extensions referenced. These can be found under the 'extensions' tab."))))))}}]),t}(i.a.Component),dt=a(194),ft=a.n(dt),gt=a(195),bt=a.n(gt),yt=a(196),vt=a.n(yt),_t=a(197),Et=a.n(_t),xt=a(198),wt=a.n(xt),kt=a(199),Mt=a.n(kt),Tt=function(e){function t(){return Object(o.a)(this,t),Object(m.a)(this,Object(u.a)(t).call(this))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return i.a.createElement(P.a,{container:!0,spacing:3,className:"stats__grid"},i.a.createElement(P.a,{item:!0,xs:12},i.a.createElement(he.a,{className:"stats__text"},i.a.createElement(q.a,{variant:"h4",align:"center",gutterBottom:!0},"Extensions ",i.a.createElement("br",null)," \xa0"),i.a.createElement(oe,{title:"Question 1",avatar:i.a.createElement(Re.a,null),expanded:!1},i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,{gutterBottom:!0},"The problem with the vectorised method specified in the main text is that we have to specify how many spikes we wish to calculate (which might lead to a final duration lower or higher than the specified spike train duration ",i.a.createElement(de.InlineMath,null,"T"),"). To solve this issue, we could oversample and discard the samples that lead to trains longer than ",i.a.createElement(de.InlineMath,null,"T"),". The question is then by how much should we oversample so that we always have enough samples to reach ",i.a.createElement(de.InlineMath,null,"T")," but also minimising the number of samples for better computational efficiency. Since we are usually using Poisson rates (",i.a.createElement(de.InlineMath,null,"\\text{r}\\times T"),") of above 100, we may approximate the Poisson by a Gaussian distribution and hence, if we oversample by 3 standard deviations, we will get that 99.7% of trials will have enough samples to reach ",i.a.createElement(de.InlineMath,null,"T")," and since this number depends on the rate, it is a good lower bound. The standard deviation in this case is ",i.a.createElement(de.InlineMath,null,"\\sqrt{\\text{r}T}"),".",i.a.createElement("br",null),i.a.createElement("br",null),"To the right, we see that the distribution of spike train durations is shaped like a Gaussian when",i.a.createElement(de.InlineMath,null,"\\text{r} = 100")," and ",i.a.createElement(de.InlineMath,null,"T=5")," for the vector method. ",i.a.createElement("br",null),"The bottom left graph shows us the distribution of the spike train durations if we use the iterative method. This method is much much slower (~30-50 times slower). ",i.a.createElement("br",null),"Finally, the bottom right graph shows us the distribution if we use the vectorised method with oversampling of 3 standard deviations. We see that this distribution is very similar to the one with the iterative method. The oversampling leads to a very small increasing in computing time (~0.01ms)."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def performance_experiment(r, T, n, oversample=True, iterative=False, bins=50):\n    """\n    Experiment that compares spike train duration distribution and computation time\n    """\n    tic = perf_counter()    # Performance timer\n    if iterative:\n        t = homogeneous_poisson_iterative(r, T, n=n)\n    else:\n        t = homogeneous_poisson(r, T, n=n, oversample=oversample)\n    toc = perf_counter()\n'+"    print('Spike train generation (single train): ' + str(round((toc-tic)*1000/n, 5)) + ' ms')  # Take average performance time\n    plt.hist([i[-1]for i in t], bins=bins, fill=None, ec=plt.rcParams['axes.prop_cycle'].by_key()['color'][0]) # Histogram of final spike time\n    plt.xlabel('Spike train duration (s)')\n    plt.ylabel('Histogram count')\n    plt.show()\n\nbins = np.linspace(9.92, 10, 51)\nprint('No oversampling')\nperformance_experiment(100, 10, 100000, oversample=False)\nprint('Iterative method ')\nperformance_experiment(100, 10, 10000, iterative=True, bins=bins)\nprint('Vectorised method with oversampling')\nperformance_experiment(100, 10, 10000, bins=bins)")),i.a.createElement(q.a,{gutterBottom:!0},i.a.createElement("br",null),i.a.createElement("br",null),"To prove the forms of ",i.a.createElement(de.InlineMath,null,"\\text{p}_{\\tau}[\\tau]")," (probability density of the ISI) and",i.a.createElement(de.InlineMath,null,"\\text{P}_N[n]")," (probability of ",i.a.createElement(de.InlineMath,null,"n")," spikes firing within the interval ",i.a.createElement(de.InlineMath,null,"T"),"), we start with considering the probability of a spike firing within one of ",i.a.createElement(de.InlineMath,null,"M")," small time bins ",i.a.createElement(de.InlineMath,null,"\\Delta t = \\frac{T}{M}"),"(small enough so two spikes can never fall in the same bin). This probability is equal to ",i.a.createElement(de.InlineMath,null,"\\text{r}\\Delta t"),", the fraction of trials during which there was a spike within the given bin.",i.a.createElement("br",null),"The probability of ",i.a.createElement(de.InlineMath,null,"n")," spikes firing within an interval ",i.a.createElement(de.InlineMath,null,"T")," is the product of the probability of generating ",i.a.createElement(de.InlineMath,null,"n")," spikes within a given set of bins ",i.a.createElement(de.InlineMath,null,"(\\text{r}\\Delta t)^n"),", the probability of generating no spikes in the remaining bins ",i.a.createElement(de.InlineMath,null,"(1-\\text{r}\\Delta t)^{M-n}")," and a combinatorial factor",i.a.createElement(de.InlineMath,null,"M \\choose n"),". Taking the limit as the bin sizes go to zero, we get that:",i.a.createElement(de.BlockMath,null,"\\text{P}_N[n]=\\lim_{\\Delta t\\to 0}\\frac{M!}{(M-n)!n!}(\\text{r}\\Delta t)^n(1-\\text{r}\\Delta t)^{M-n}"),"To evaluate this limit, we take the limit of the three parts separately. For the binomial coefficient, we note that ",i.a.createElement(de.InlineMath,null,"M")," grows without bound since ",i.a.createElement(de.InlineMath,null,"M = \\frac{T}{\\Delta t}"),".This means that:",i.a.createElement(de.BlockMath,null,"\\lim_{\\Delta t \\to 0}\\frac{M!}{(M-n)!} = \\lim_{\\Delta t \\to 0}M \\times (M-1) \\times\\dots\\times(M-n+1) = M^n"),"since ",i.a.createElement(de.InlineMath,null,"n")," is constant and ",i.a.createElement(de.InlineMath,null,"M")," tends towards infinity. This result cancels with the second term since ",i.a.createElement(de.InlineMath,null,"\\Delta t^n \\propto \\frac{1}{M^n}"),". For the final term, we make the following substitution: ",i.a.createElement(de.InlineMath,null,"\\epsilon = -\\text{r}\\Delta t")," from which we get:",i.a.createElement(de.BlockMath,null,"\\lim_{\\Delta t \\to 0}(1-\\text{r}\\Delta t)^{M-n} = \\lim_{\\epsilon \\to 0}\\Big((1+\\epsilon)^{\\frac{1}{\\epsilon}}\\Big)^{-\\text{r}T} = e^{-\\text{r}T}"),"which follows from the definition that:",i.a.createElement(de.BlockMath,null,"\\lim_{\\epsilon\\to 0}(1+\\epsilon)^{\\frac{1}{\\epsilon}}=e"),"Putting this together we get that:",i.a.createElement(de.BlockMath,null,"\\text{P}_N[n] = \\frac{M^n}{n!}\\frac{(\\text{r}T)^n}{M^n}e^{-\\text{r}T}= \\frac{(\\text{r}T)^n}{n!}e^{-\\text{r}T} = \\text{Po}(n;\\lambda=\\text{r}T)"),i.a.createElement("br",null),i.a.createElement("br",null),"For the ISI, we note that the the probability of a spike being generated withing the interval ",i.a.createElement(de.InlineMath,null,"[\\tau, \\tau+\\Delta t]"),"is the probability that no spike is fired over a time ",i.a.createElement(de.InlineMath,null,"\\tau")," (",i.a.createElement(de.InlineMath,null,"\\text{P}_N[0]=e^{-\\text{r}\\tau}"),") multiplied by the probability of a spike firing withing a small interval (",i.a.createElement(de.InlineMath,null,"\\text{r}\\Delta t"),"). To get the probability density, we just divide by ",i.a.createElement(de.InlineMath,null,"\\Delta t")," to get:",i.a.createElement(de.BlockMath,null,"\\text{p}_{\\tau}[\\tau] = \\text{r} e^{-\\text{r}\\tau} = \\text{Exp}\\Big(\\tau;\\lambda=\\frac{1}{\\text{r}}\\Big)"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(Be.a,{image:ft.a,className:"neur__questions__image"}),i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:bt.a,className:"neur__questions__image"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:vt.a,className:"neur__questions__image"})))))),i.a.createElement(oe,{title:"Question 2",avatar:i.a.createElement(Re.a,null),expanded:!1},i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,{gutterBottom:!0},"It has been suggested that a gamma distribution of the form:",i.a.createElement(de.BlockMath,null,"\\text{p}_{\\tau}[\\tau] = \\frac{\\text{r}(\\text{r}\\tau)^ke^{-\\text{r}\\tau}}{k!} = \\text{Gamma}(k+1, \\text{r})"),"desribes these distributions. The question now is how ",i.a.createElement(de.InlineMath,null,"k")," depends on ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}"),". To answer this question, we will find the analytic mean and variance of this function and then fit this to the experimental results.",i.a.createElement(de.BlockMath,null,"\\begin{aligned}\n\\langle\\tau\\rangle &= \\int^{\\infty}_0 \\tau \\frac{\\text{r}(\\text{r}\\tau)^ke^{-\\text{r}\\tau}}{k!} \\text{d}\\tau = \\frac{\\Gamma(k+2)}{\\text{r}k!} = \\frac{k+1}{\\text{r}}\\\\\n\\sigma_{\\tau}^2 &= \\int^{\\infty}_0 \\tau^2 \\frac{\\text{r}(\\text{r}\\tau)^ke^{-\\text{r}\\tau}}{k!} \\text{d}\\tau - \\langle\\tau\\rangle^2 = \\frac{\\Gamma(k+3)}{\\text{r}^2k!} - \\langle\\tau\\rangle^2\\\\\n&= \\frac{(k+2)(k+1)}{\\text{r}^2} -  \\frac{(k+1)^2}{\\text{r}^2} = \\frac{k+1}{\\text{r}^2}\\\\\nC_V &= \\frac{\\sigma_{\\tau}}{\\langle\\tau\\rangle}=\\frac{1}{\\sqrt{k+1}}\n\\end{aligned}"),"We can plot ",i.a.createElement(de.InlineMath,null,"\\text{r}\\langle\\tau\\rangle - 1")," and ",i.a.createElement(de.InlineMath,null,"\\text{r}^2\\sigma_{\\tau}^2 - 1"),"\xa0against ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}")," and see whether the curves line up to determine a relationship between \xa0",i.a.createElement(de.InlineMath,null,"k")," and ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}"),". In our case, we see that the curves have different forms: the variance seems to follow a linear trend, and the mean a combination of a linear and decaying exponential. An interesting feature is that they intersect at around \xa0",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}=38"),"ms. This suggests that our assumption about the model only depending on one latent variable \xa0(",i.a.createElement(de.InlineMath,null,"k"),") is likely wrong. This method of parameter estimation is a variant of the method of moments."),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def mean_fit(x):\n    """\n    Function that fits tau_ref to k fitted on the mean of the ISIs\n    """\n    A = 2.29\n    B = 0.0252\n    C = 0.0116\n    return A*(1-np.exp(-B*x)) + C*x\n\n\ndef var_fit(x):\n    """\n    Function that fits tau_ref to k fitted on the variance of the ISIs\n    """\n    A = 0.05\n    return A*x\n\n\nmeans = []\nvariances = []\ncvs = []\ntaus = np.linspace(1, 100, 100)\nfor tau in taus:\n    t = refractory_homogeneous_poisson(100, 10, tau/1000, 30)\n    means.append(np.mean(to_isi(t, join=True))*100 - 1)\n    variances.append(np.var(to_isi(t, join=True))*10000 - 1)\n\n'+"plt.scatter(taus, means, label=r'$\\displaystyle\\text{r}\\langle\\tau\\rangle - 1$', marker='.')\nplt.scatter(taus, variances, label=r'$\\displaystyle\\text{r}^2\\sigma_{\\tau}^2 - 1$', marker='.')\nplt.plot(taus, mean_fit(taus), label='Mean fit', c='r')\nplt.plot(taus, var_fit(taus), label='Var fit', c='b')\nplt.xlabel(r'$\\displaystyle\\tau_{\\text{ref}}$ (ms)')\nplt.ylabel('k')\nplt.legend()\nplt.show()"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(Be.a,{image:Et.a,className:"neur__questions__image"}))),i.a.createElement("hr",{className:"neur__hr"}),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(q.a,null,"Using the mean as an example metric, we fit a curve of the form",i.a.createElement(de.BlockMath,null,"f(\\tau_{\\text{ref}}) = A(1-e^{-B\\tau_{\\text{ref}}}) + C\\tau_{\\text{ref}}"),"and use this to plot some gamma functions against our ISI distribution. These plots show an expected trend, that the fit is best around ",i.a.createElement(de.InlineMath,null,"\\tau_{\\text{ref}}=38")," ms and worse the further deviated from this. We repeat this for the variance fit of form",i.a.createElement(de.BlockMath,null,"f(\\tau_{\\text{ref}}) = D\\tau_{\\text{ref}}")),i.a.createElement(oe,{title:"Code",avatar:i.a.createElement(Se.a,null),expanded:!1},i.a.createElement(We.a,{language:"python"},'def mom_experiment(tau, fit):\n    """\n    Runs an instant of a _fit experiment which fits a gamma distribution with the corresponding k value to the simulated data\n    """\n    x = np.linspace(0, 200, 100)\n    t = refractory_homogeneous_poisson(100, 10, tau/1000, 30)\n    plot_interval_hist(t, 0, True, 0.33, label=\'Data\', density=True,\n'+"                       title=fit + r' fit ($\\displaystyle\\tau_{\\text{ref}}=$' + str(tau) + 'ms)')\n    if fit == 'Mean':\n        k = mean_fit(tau)\n    elif fit == 'Variance':\n        k = var_fit(tau)\n    plt.plot(x, gamma.pdf(x, 1 + k, scale=1000/100), label='Gamma fit')\n\nfig = matplotlib.pyplot.gcf()\nfig.set_size_inches(10, 10)\nplt.subplot(3, 1, 1)\nmom_experiment(15, 'Mean')\nplt.xlabel('')\nplt.legend()\nplt.subplot(3, 1, 2)\nmom_experiment(38, 'Mean')\nplt.xlabel('')\nplt.subplot(3, 1, 3)\nmom_experiment(100, 'Mean')\nplt.tight_layout()\nplt.show()\n\nfig = matplotlib.pyplot.gcf()\nfig.set_size_inches(10, 10)\nplt.subplot(3, 1, 1)\nmom_experiment(15, 'Variance')\nplt.xlabel('')\nplt.legend()\nplt.subplot(3, 1, 2)\nmom_experiment(38, 'Variance')\nplt.xlabel('')\nplt.subplot(3, 1, 3)\nmom_experiment(100, 'Variance')\nplt.tight_layout()\nplt.show()"))),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridR"},i.a.createElement(P.a,{container:!0,spacing:0,justify:"center"},i.a.createElement(P.a,{key:0,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:wt.a,className:"neur__questions__image--square"})),i.a.createElement(P.a,{key:1,item:!0,className:"neur__questions__gridL"},i.a.createElement(Be.a,{image:Mt.a,className:"neur__questions__image--square"})))))),i.a.createElement("hr",{className:"neur__hr"}),i.a.createElement(P.a,{container:!0,spacing:3,justify:"center"},i.a.createElement(q.a,{gutterBottom:!0},"While these fits do show some qualitative deviation from our proposed model, ideally we would want some way to quantify this. This is where EDF (empirical distribution function) statistics come into play. Initially, the Kolmogorov-Smirnov test was thought to be a good way to quantify the goodness of fit of our model but it was later found that the p-values of this test are significantly shifted if the model contained parameters that were estimated from data (which is done here in the case of the shape parameter ",i.a.createElement(de.InlineMath,null,"1+k"),").",i.a.createElement("br",null),i.a.createElement("br",null),"To account for this estimation, we turn to Goodness-of-Fit-Techniques by Ralph B. D'Agostino where methods are discussed that deal with the case where the shape parameter of a gamma distribution is estimated. The steps of the method are as follows:",i.a.createElement("ol",null,i.a.createElement("li",null,"Put the sample in ascending order ",i.a.createElement(de.InlineMath,null,"X_{(1)}<\\dots <X_{(n)}")),i.a.createElement("li",null,"Estimate ",i.a.createElement(de.InlineMath,null,"m=k+1")," by maximum likelihood estimation (",i.a.createElement(de.InlineMath,null,"\\hat m"),")"),i.a.createElement("li",null,"Calculate ",i.a.createElement(de.InlineMath,null,"Z_{(i)}=\\frac{1}{\\beta^{\\hat{m}}\\Gamma(\\hat m)}\\int_0^{X_i}x^{\\hat m-1}e^{\\frac{-x}{\\beta}}\\text{dx}"),"\xa0for ",i.a.createElement(de.InlineMath,null,"i=1,\\dots ,n")," (where ",i.a.createElement(de.InlineMath,null,"\\beta = \\text{r}"),")"),i.a.createElement("li",null,"Calculate the EDF statistics using the values of ",i.a.createElement(de.InlineMath,null,"Z_{(i)}")),i.a.createElement("li",null,"Reject the null hypothesis that the the data follows the given distribution if the the value of the statistics are greater than the tabulated values for a desired significance level ",i.a.createElement(de.InlineMath,null,"\\alpha")," and for appropriate ",i.a.createElement(de.InlineMath,null,"\\hat m"))),"We will first assume that in step 2, our variant of the method of moments is used to estimate ",i.a.createElement(de.InlineMath,null,"m")," and we will later discuss the MLE solution. We will now show that the integral in step 3 can be simplified to the incomplete gamma function:",i.a.createElement(de.BlockMath,null,"\\Gamma_{\\text{inc}}(X; m)=\\frac{1}{\\Gamma(m)}\\int_0^X x^{m-1}e^{-m}\\text{dx}"),"Using the substitution ",i.a.createElement(de.InlineMath,null,"x'=\\frac{x}{\\beta}")," we can obtain the desired result:",i.a.createElement(de.BlockMath,null,"\\begin{aligned}\nZ_{(i)}&=\\frac{1}{\\beta^{\\hat{m}}\\Gamma(\\hat{m})}\\int_0^{X_i}(x'\\beta)^{\\hat{m}-1}e^{-x'}\\beta \\text{dx'}\\\\\n                    &=\\frac{\\beta^{\\hat{m}-1}\\beta}{\\beta^{\\hat{m}}}\\Gamma_{\\text{inc}}(X_{(i)};\\hat{m})=\\Gamma_{\\text{inc}}(X_{(i)};\\hat{m})\n                    \\end{aligned}"),"Finally, the EDF statistics that we will be using include the Kolmogorov statistic ",i.a.createElement(de.InlineMath,null,"D")," (for which no p-values are available so we will simply state it) defined as:",i.a.createElement(de.BlockMath,null,"D = \\sup_x|F_n(x)-F(x)|"),"where ",i.a.createElement(de.InlineMath,null,"F(x)")," is the cdf of the model distribution (gamma distribution in our case) and ",i.a.createElement(de.InlineMath,null,"F_n(x)")," is the empirical cumulative distribution function which we will obtain from the data. This statistic is part of the ",i.a.createElement("i",null,"supremum statistics"),"\xa0which are different from the other three statistics we will now describe.",i.a.createElement("br",null),i.a.createElement("br",null),"The Cram\xe9r\u2013von Mises statistic, ",i.a.createElement(de.InlineMath,null,"W^2"),", and the Anderson-Darling statistic, ",i.a.createElement(de.InlineMath,null,"A^2"),", are both of the form:",i.a.createElement(de.BlockMath,null,"Q = n\\int^\\infty_{-\\infty}\\big(F_n(x)-F(x)\\big)^2\\psi(x)\\text{dF(x)}"),"where ",i.a.createElement(de.InlineMath,null,"\\psi(x) = 1")," for ",i.a.createElement(de.InlineMath,null,"W^2")," and ",i.a.createElement(de.InlineMath,null,"\\psi(x) = \\frac{1}{F(x)(1-F(x))}"),"for ",i.a.createElement(de.InlineMath,null,"A^2"),". Finally, the last statistic we will calculate is the Watson statistic, ",i.a.createElement(de.InlineMath,null,"U^2")," which has a slightly different format:",i.a.createElement(de.BlockMath,null,"U^2=n\\int^\\infty_{-\\infty}\\Big\\{F_n(x)-F(x)-\\int_{-\\infty}^\\infty \\big\\{F_n(x)-F(x)\\big\\}\\text{dF(x)}\\Big\\}^2\\text{dF(x)}"),"These three statistics belong to the quadratic statistics and we will obtain p-values for all three and hence, be able to use these for step 5."))))))}}]),t}(i.a.Component),jt=function(e){function t(){return Object(o.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return i.a.createElement("div",null,i.a.createElement(D,null),i.a.createElement("div",{className:"home"===this.props.selectedTab?"":"invisible"},i.a.createElement("header",{className:"App-header"},i.a.createElement("img",{src:d.a,className:"App-logo",alt:"logo"}),"Data Visualisation")),i.a.createElement("div",{className:"normal"===this.props.selectedTab?"":"invisible"},i.a.createElement(Te,null)),i.a.createElement("div",{className:"poisson"===this.props.selectedTab?"":"invisible"},i.a.createElement(Pe,null)),i.a.createElement("div",{className:"neurInfo"===this.props.selectedTab?"":"invisible"},i.a.createElement(pt,null)),i.a.createElement("div",{className:"chapter1"===this.props.selectedTab?"":"invisible"},i.a.createElement(lt,null)),i.a.createElement("div",{className:"neurExt"===this.props.selectedTab?"":"invisible"},i.a.createElement(Tt,null)),i.a.createElement("div",{className:"rayTracing"===this.props.selectedTab?"":"invisible"},i.a.createElement(mt,null)),i.a.createElement("div",{className:"ipython"===this.props.selectedTab?"":"invisible"},i.a.createElement(ot,null)))}}]),t}(i.a.Component);var Nt=Object(j.b)((function(e){return{selectedTab:e.selectedTab}}))(jt),It=a(157);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));var Ot=a(110),Ct=a(200),Dt=a(467);function Pt(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}var Rt=Object(Ct.a)({palette:{type:"dark",secondary:{main:"#FFFFFF"}}}),St={mean:{normal:1,poisson:100},stDev:{normal:10,poisson:10},lambda:{poisson:5},samples:{normal:1e3,poisson:1e3},updateData:{normal:!1,poisson:!1},performanceChart:{normal:!1,poisson:!1},selectedTab:"home"};var Bt=Object(It.b)((function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:St,t=arguments.length>1?arguments[1]:void 0;switch(t.type){case"SLIDER_CHANGE":return Object(Ot.a)(e,(function(e){e[t.value][t.name]=function(e){var t=Math.floor((e+Math.floor(e/10))/10);return(e+t)%10*Math.pow(10,t)}(t.newValue)}));case"INPUT_CHANGE":return Object(Ot.a)(e,(function(e){e[t.value][t.name]=""===t.event.target.value?"":Number(t.event.target.value)}));case"CLIP":return e[t.value][t.name]>t.max?Object(Ot.a)(e,(function(e){e[t.value][t.name]=t.max})):e[t.value][t.name]<0?Object(Ot.a)(e,(function(e){e[t.value][t.name]=0})):e;case"TOGGLE_UPDATE_DATA":return Object(Ot.a)(e,(function(a){a.updateData[t.name]=!e.updateData[t.name]}));case"TOGGLE_PERFORMANCE_CHART":return Object(Ot.a)(e,(function(a){a.updateData[t.name]=!e.updateData[t.name],a.performanceChart[t.name]=!e.performanceChart[t.name]}));case"SET_TAB":return function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?Pt(a,!0).forEach((function(t){Object(n.a)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):Pt(a).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}({},e,{selectedTab:t.value});default:return e}}));l.a.render(i.a.createElement(j.a,{store:Bt},i.a.createElement(Dt.a,{theme:Rt},i.a.createElement(Nt,null))),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}},[[210,1,3]]]);
//# sourceMappingURL=main.5c3e340a.chunk.js.map